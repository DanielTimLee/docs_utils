/*
 *  Usage: ./insmod ./drv_sendsignal.ko ProcessID=1021 SignalNumber=12
 *         ./insmod ./drv_sendsignal.ko ProcessID=1021
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/kernel.h>
#include <linux/sched.h>
#include <linux/errno.h>
#include <linux/vmalloc.h>
#include <linux/wait.h>
#include <linux/proc_fs.h>
#include <linux/sysctl.h>
#include <linux/signal.h>
#include <linux/interrupt.h>
#include <linux/unistd.h>
#include <linux/smp_lock.h>
#include <linux/slab.h>
#include <linux/sched.h>
#include <linux/types.h>
#include <linux/timex.h>
#include <linux/jiffies.h>
#include <linux/fs.h>
#include <linux/tty.h>
#include <linux/binfmts.h>
#include <linux/security.h>
#include <linux/ptrace.h>
#include <asm/param.h>
#include <asm/uaccess.h>
#include <asm/siginfo.h>
#include <asm/unistd.h>

/**
 * Global data that can be override by parameters
 */ 
static int   SignalNumber = 14;
static pid_t ProcessID    = -1;

/**
 * Parameters definition
 */
module_param(SignalNumber, int, S_IRUGO);	// Not mandatory
module_param(ProcessID,    int, S_IRUGO);	// Mandatory

/**
 * @brief init function
 */
static int signal_init_module(void)
{
     struct siginfo      info;
     struct task_struct* task   = NULL;
     int                 rc_drv	= 0;
     
     printk( KERN_INFO "\nInitialization of the driver" );
     
     /*
      * Testing the parameters
      */ 
     if ( -1 == ProcessID )
     {
        printk( KERN_ERR "You should provide the PID of the process to notify by a signal " );
	printk( KERN_ERR "./insmod ./drv_sendsignal.ko ProcessID=1021 SignalNumber=12       " );
	printk( KERN_ERR "./insmod ./drv_sendsignal.ko ProcessID=1021                       " );
	rc_drv = -1;
     } else {
        /*
	 * Initialising the data struct
	 */
	memset(&info, 0, sizeof(struct siginfo));
	info.si_signo = -SignalNumber;		/* contains the signal number generated by the system		*/
	info.si_errno = 0;			/* is non-zero, then it contains a system specific error number */
						/* associated with this signal					*/
	info.si_code  = SI_QUEUE;
	//info.si_code  = SI_USER;		/* is less than or equal to zero, the signal was generated 	*/
						/* by a user process or a user requested service		*/
	info.si_pid   = current->tgid;		/* contains the pid of the sending process			*/
	//info.si_uid   = current->uid;		/* contains the user id of the sending process			*/

        /*
	 * Find the task from pid  
	 */
	task_struct = find_task_by_vpid(ProcessID);  
	
	/*
	 * Sending signal to the userspace
	 */
	printk( KERN_INFO "--> Sending signal to userspace (process ID : %d)", ProcessID );
	//kill_proc(SignalNumber, &info, ProcessID);
	//kill_proc(ProcessID, SignalNumber, 0);
	send_sig_info(SignalNumber, &info, task);
     } /* if */
     
     return(rc_drv);
} /* signal_init_module */

/**
 * @brief cleanup function
 */
static void signal_cleanup_module(void)
{
     printk( KERN_INFO "Exit the driver!!" );
} /* signal_cleanup_module */

MODULE_LICENSE("GPL");

module_init(signal_init_module);
module_exit(signal_cleanup_module);
